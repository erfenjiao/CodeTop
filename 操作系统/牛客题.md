

每个进程一张段表，每个段一张页表，所以总共来说是多个页表！   



可重入函数可认为是可以被中断的函数，自动变量定义的时候才被创建，函数返回时，系统回收空间，他是的是局部作用域变量，不需要互斥量。可重入函数对全局变量才需要互斥量保护。



   在 实时系统的设计中，经常会出现多个任务调用同一个函数的情况。如果这个函数不幸被设计成为不可重入的函数的话，那么不同任务调用这个函数时可能修改其他任    务调用这个函数的数据，从而导致不可预料的后果。那么什么是可重入函数呢？所谓可重入是指一个可以被多个任务调用的过程，任务在调用时不必担心数据是否会 出错。不可重入函数在实时系统设计中被视为不安全函数。

  满足下列条件的函数多数是不可重入的：  
 （1）函数体内使用了静态的数据结构；   
 （2）函数体内调用了malloc()或者free()函数；   
 （3）函数体内调用了标准I/O函数。 
  如何写出可重入的函数？在函数体内不访问那些全局变量，不使用静态局部变量，坚持只使用缺省态（auto）局部变量，写出的函数就将是可重入的。如果必须访问全局变量，记住利用互斥信号量来保护全局变量。或者调用该函数前关中断，调用后再开中断。 

  可重入函数可以被一个以上的任务调用，而不必担心数据被破坏。可重入函数任何时候都可以被中断，一段时间以后又可以运行，而相应的数据不会丢失。可重入函数或者只使用局部变量，即保存在CPU寄存器中或堆栈中；或者使用全局变量，则要对全局变量予以保护。 



进程同步的引入背景： 

  在多道程序环境下，进程是并发执行的，不同进程之间存在着不同的相互制约关系。为了协调进程之间的相互制约关系，引入了进程同步的概念。



进程同步的出现跟死锁没有关系，死锁是因为多个进程争夺资源彼此相互等待对方释放已占有的资源，造成无限期等待。进程同步是为了协调进程使用资源。





如果将固定块大小的文件系统中的块大小设置大一些，会造成（更好的磁盘吞吐量和更差的磁盘空间利用率）。

**文件是按块存储的，如果取更大的块，一次读取时会得到更多的数据，即磁盘吞吐率提高；但大块也会导致有时数据装不满，从而磁盘利用率下降**





所谓的大端模式（Big-endian），是指数据的高字节，保存在内存的低地址中，而数据的低字节，保存在内存的高地址中，这样的存储模式有点儿类似于把数据当作字符串顺序处理：地址由小向大增加，而数据从高位往低位放； 

 

  所谓小端模式（Little-endian）, 是指数据的高字节保存在内存的高地址中,而数据的低字节保存在内在的低地址中,这种存储模式将地址的高低和数据位 权有效结合起来,高地址部分权值高,低地址部分权值低,和我们的逻辑方法一致



虚拟设备都是通过spooling技术将一***占设备或者共享设备虚拟成多个逻辑设备，供多个用户进行访问。 





下列操作系统强调交互性的系统是（分时系统  ）

分时系统：将CPU的执行时间分成一个个的时间片(time slice)，多用户中的每个用户轮转时间片，非常适合交互型作业； 



  实时系统主要用于专用系统(used in dedicated application)，有着非常严格的固定时间要求(well-defined ***fixed-time\*** constraints) ；



## 内零头和外零头

下面的内存管理模式中，会产生外零头的是（）

A 页式

B 段式

C 请求页式

D 请求段式



## 单处理机计算机系统





## buddy内存分配算法