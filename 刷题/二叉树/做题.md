# 226 反转二叉树



递归

1. 确定参数和返回值
2. 确定终止条件
3. 确定单层递归逻辑



# 101 对称二叉树





# 104 二叉树的最大深度





# 559 N 叉树的最大深度

前序遍历和后序遍历都可以，前序求的是深度，后序求的是高度。



# 111 二叉树的最小深度

前序遍历和后序遍历都可以，前序求的是深度，后序求的是高度。

- 二叉树节点的深度：指从根节点到该节点的最长简单路径边的条数或者节点数（取决于深度从0开始还是从1开始）
- 二叉树节点的高度：指从该节点到叶子节点的最长简单路径边的条数后者节点数（取决于高度从0开始还是从1开始）



易错点：

![111.二叉树的最小深度](https://code-thinking.cdn.bcebos.com/pics/111.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%B0%8F%E6%B7%B1%E5%BA%A6.png)



如果这么求的话，没有左孩子的分支会算为最短深度。

所以，如果左子树为空，右子树不为空，说明最小深度是 1 + 右子树的深度。

反之，右子树为空，左子树不为空，最小深度是 1 + 左子树的深度。 最后如果左右子树都不为空，返回左右子树深度最小值 + 1 。



测试用例：
[2,null,3,null,4,null,5,null,6]
输出：
1

预期结果：

5



# 222 完全二叉树的节点个数

方法一： 普通二叉树求解

方法二： 使用完全二叉树的特点求解





方法二：完全二叉树只有两种情况

> 情况一：就是满二叉树
>
> 情况二：最后一层叶子节点没有满。

对于情况一，可以直接用 2^树深度 - 1 来计算，注意这里根节点深度为1。

对于情况二，分别递归左孩子，和右孩子，递归到某一深度一定会有左孩子或者右孩子为满二叉树，然后依然可以按照情况1来计算。

可以看出如果整个树不是满二叉树，就递归其左右孩子，直到遇到满二叉树为止，用公式计算这个子树（满二叉树）的节点数量。

这里关键在于如何去判断一个左子树或者右子树是不是满二叉树呢？

在完全二叉树中，如果递归向左遍历的深度等于递归向右遍历的深度，那说明就是满二叉树。如图：

<img src="https://code-thinking-1253855093.file.myqcloud.com/pics/20201124092634138.png" alt="222.完全二叉树的节点个数1" style="zoom:50%;" />



# 110.平衡二叉树

